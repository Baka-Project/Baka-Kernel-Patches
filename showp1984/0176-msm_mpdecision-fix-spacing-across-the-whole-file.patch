From bc6d38a435b839a2c46853ac64c5e7745b5bde52 Mon Sep 17 00:00:00 2001
From: Dennis Rassmann <showp1984@gmail.com>
Date: Sun, 21 Apr 2013 09:11:12 +0200
Subject: [PATCH 176/338] msm_mpdecision: fix spacing across the whole file In
 the past year this evolved to a battlefield of
 tabs, spaces and different sizes of them. Fix that.

Signed-off-by: Dennis Rassmann <showp1984@gmail.com>
Signed-off-by: Simarpreet Singh <simar@linux.com>
---
 arch/arm/mach-msm/msm_mpdecision.c | 1002 ++++++++++++++++++------------------
 1 file changed, 496 insertions(+), 506 deletions(-)

diff --git a/arch/arm/mach-msm/msm_mpdecision.c b/arch/arm/mach-msm/msm_mpdecision.c
index 6387b2d..b4c5ee9 100644
--- a/arch/arm/mach-msm/msm_mpdecision.c
+++ b/arch/arm/mach-msm/msm_mpdecision.c
@@ -44,20 +44,20 @@
 #define MSM_MPDEC_IDLE_FREQ             486000
 
 enum {
-	MSM_MPDEC_DISABLED = 0,
-	MSM_MPDEC_IDLE,
-	MSM_MPDEC_DOWN,
-	MSM_MPDEC_UP,
+    MSM_MPDEC_DISABLED = 0,
+    MSM_MPDEC_IDLE,
+    MSM_MPDEC_DOWN,
+    MSM_MPDEC_UP,
 };
 
 struct msm_mpdec_cpudata_t {
-	struct mutex suspend_mutex;
-	int online;
-	int device_suspended;
-	cputime64_t on_time;
-	cputime64_t on_time_total;
-	long long unsigned int times_cpu_hotplugged;
-	long long unsigned int times_cpu_unplugged;
+    struct mutex suspend_mutex;
+    int online;
+    int device_suspended;
+    cputime64_t on_time;
+    cputime64_t on_time_total;
+    long long unsigned int times_cpu_hotplugged;
+    long long unsigned int times_cpu_unplugged;
 };
 static DEFINE_PER_CPU(struct msm_mpdec_cpudata_t, msm_mpdec_cpudata);
 
@@ -66,21 +66,21 @@ static struct workqueue_struct *msm_mpdec_workq;
 static DEFINE_MUTEX(mpdec_msm_cpu_lock);
 
 static struct msm_mpdec_tuners {
-	unsigned int startdelay;
-	unsigned int delay;
-	unsigned int pause;
-	bool scroff_single_core;
-	unsigned long int idle_freq;
-        unsigned int max_cpus;
-        unsigned int min_cpus;
+    unsigned int startdelay;
+    unsigned int delay;
+    unsigned int pause;
+    bool scroff_single_core;
+    unsigned long int idle_freq;
+    unsigned int max_cpus;
+    unsigned int min_cpus;
 } msm_mpdec_tuners_ins = {
-	.startdelay = MSM_MPDEC_STARTDELAY,
-	.delay = MSM_MPDEC_DELAY,
-	.pause = MSM_MPDEC_PAUSE,
-	.scroff_single_core = true,
-	.idle_freq = MSM_MPDEC_IDLE_FREQ,
-        .max_cpus = CONFIG_NR_CPUS,
-        .min_cpus = 1,
+    .startdelay = MSM_MPDEC_STARTDELAY,
+    .delay = MSM_MPDEC_DELAY,
+    .pause = MSM_MPDEC_PAUSE,
+    .scroff_single_core = true,
+    .idle_freq = MSM_MPDEC_IDLE_FREQ,
+    .max_cpus = CONFIG_NR_CPUS,
+    .min_cpus = 1,
 };
 
 static unsigned int NwNs_Threshold[8] = {12, 0, 25, 20, 32, 28, 0, 35};
@@ -93,275 +93,266 @@ unsigned int state = MSM_MPDEC_IDLE;
 bool was_paused = false;
 static cputime64_t mpdec_paused_until = 0;
 
-static unsigned long get_rate(int cpu)
-{
-        return acpuclk_get_rate(cpu);
+static unsigned long get_rate(int cpu) {
+    return acpuclk_get_rate(cpu);
 }
 
-static int get_slowest_cpu(void)
-{
-        int i, cpu = 0;
-        unsigned long rate, slow_rate = 0;
-
-        for (i = 1; i < CONFIG_NR_CPUS; i++) {
-                if (!cpu_online(i))
-                        continue;
-
-                rate = get_rate(i);
-                if (slow_rate == 0) {
-                        slow_rate = rate;
-                }
-
-                if ((rate <= slow_rate) && (slow_rate != 0)) {
-                        cpu = i;
-                        slow_rate = rate;
-                }
+static int get_slowest_cpu(void) {
+    int i, cpu = 0;
+    unsigned long rate, slow_rate = 0;
+
+    for (i = 1; i < CONFIG_NR_CPUS; i++) {
+        if (!cpu_online(i))
+            continue;
+        rate = get_rate(i);
+        if (slow_rate == 0) {
+            slow_rate = rate;
+        }
+        if ((rate <= slow_rate) && (slow_rate != 0)) {
+            cpu = i;
+            slow_rate = rate;
         }
+    }
 
-        return cpu;
+    return cpu;
 }
 
-static unsigned long get_slowest_cpu_rate(void)
-{
-        int i = 0;
-        unsigned long rate, slow_rate = 0;
-
-        for (i = 0; i < CONFIG_NR_CPUS; i++) {
-                if (!cpu_online(i))
-                        continue;
-                rate = get_rate(i);
-                if ((rate < slow_rate) && (slow_rate != 0)) {
-                        slow_rate = rate;
-                }
-                if (slow_rate == 0) {
-                        slow_rate = rate;
-                }
+static unsigned long get_slowest_cpu_rate(void) {
+    int i = 0;
+    unsigned long rate, slow_rate = 0;
+
+    for (i = 0; i < CONFIG_NR_CPUS; i++) {
+        if (!cpu_online(i))
+            continue;
+        rate = get_rate(i);
+        if ((rate < slow_rate) && (slow_rate != 0)) {
+            slow_rate = rate;
         }
+        if (slow_rate == 0) {
+            slow_rate = rate;
+        }
+    }
 
-        return slow_rate;
+    return slow_rate;
 }
 
-static int mp_decision(void)
-{
-	static bool first_call = true;
-	int new_state = MSM_MPDEC_IDLE;
-	int nr_cpu_online;
-	int index;
-	unsigned int rq_depth;
-	static cputime64_t total_time = 0;
-	static cputime64_t last_time;
-	cputime64_t current_time;
-	cputime64_t this_time = 0;
-
-	if (state == MSM_MPDEC_DISABLED)
-		return MSM_MPDEC_DISABLED;
-
-	current_time = ktime_to_ms(ktime_get());
-	if (current_time <= msm_mpdec_tuners_ins.startdelay)
-		return MSM_MPDEC_IDLE;
-
-	if (first_call) {
-		first_call = false;
-	} else {
-		this_time = current_time - last_time;
-	}
-	total_time += this_time;
-
-	rq_depth = get_rq_info();
-	nr_cpu_online = num_online_cpus();
-
-	if (nr_cpu_online) {
-		index = (nr_cpu_online - 1) * 2;
-		if ((nr_cpu_online < CONFIG_NR_CPUS) && (rq_depth >= NwNs_Threshold[index])) {
-			if ((total_time >= TwTs_Threshold[index]) &&
-                            (nr_cpu_online < msm_mpdec_tuners_ins.max_cpus)) {
-				new_state = MSM_MPDEC_UP;
-                                if (get_slowest_cpu_rate() <=  msm_mpdec_tuners_ins.idle_freq)
-                                        new_state = MSM_MPDEC_IDLE;
-			}
-		} else if ((nr_cpu_online > 1) && (rq_depth <= NwNs_Threshold[index+1])) {
-			if ((total_time >= TwTs_Threshold[index+1]) &&
-                            (nr_cpu_online > msm_mpdec_tuners_ins.min_cpus)) {
-				new_state = MSM_MPDEC_DOWN;
-                                if (get_slowest_cpu_rate() > msm_mpdec_tuners_ins.idle_freq)
-			                new_state = MSM_MPDEC_IDLE;
-			}
-		} else {
-			new_state = MSM_MPDEC_IDLE;
-			total_time = 0;
-		}
-	} else {
-		total_time = 0;
-	}
-
-	if (new_state != MSM_MPDEC_IDLE) {
-		total_time = 0;
-	}
-
-	last_time = ktime_to_ms(ktime_get());
+static int mp_decision(void) {
+    static bool first_call = true;
+    int new_state = MSM_MPDEC_IDLE;
+    int nr_cpu_online;
+    int index;
+    unsigned int rq_depth;
+    static cputime64_t total_time = 0;
+    static cputime64_t last_time;
+    cputime64_t current_time;
+    cputime64_t this_time = 0;
+
+    if (state == MSM_MPDEC_DISABLED)
+        return MSM_MPDEC_DISABLED;
+
+    current_time = ktime_to_ms(ktime_get());
+    if (current_time <= msm_mpdec_tuners_ins.startdelay)
+        return MSM_MPDEC_IDLE;
+
+    if (first_call) {
+        first_call = false;
+    } else {
+        this_time = current_time - last_time;
+    }
+    total_time += this_time;
+
+    rq_depth = get_rq_info();
+    nr_cpu_online = num_online_cpus();
+
+    if (nr_cpu_online) {
+        index = (nr_cpu_online - 1) * 2;
+        if ((nr_cpu_online < CONFIG_NR_CPUS) && (rq_depth >= NwNs_Threshold[index])) {
+            if ((total_time >= TwTs_Threshold[index]) &&
+                (nr_cpu_online < msm_mpdec_tuners_ins.max_cpus)) {
+                new_state = MSM_MPDEC_UP;
+                if (get_slowest_cpu_rate() <=  msm_mpdec_tuners_ins.idle_freq)
+                    new_state = MSM_MPDEC_IDLE;
+            }
+        } else if ((nr_cpu_online > 1) && (rq_depth <= NwNs_Threshold[index+1])) {
+            if ((total_time >= TwTs_Threshold[index+1]) &&
+                (nr_cpu_online > msm_mpdec_tuners_ins.min_cpus)) {
+                new_state = MSM_MPDEC_DOWN;
+                if (get_slowest_cpu_rate() > msm_mpdec_tuners_ins.idle_freq)
+                    new_state = MSM_MPDEC_IDLE;
+            }
+        } else {
+            new_state = MSM_MPDEC_IDLE;
+            total_time = 0;
+        }
+    } else {
+        total_time = 0;
+    }
+
+    if (new_state != MSM_MPDEC_IDLE) {
+        total_time = 0;
+    }
+
+    last_time = ktime_to_ms(ktime_get());
 #if DEBUG
-        pr_info(MPDEC_TAG"[DEBUG] rq: %u, new_state: %i | Mask=[%d%d%d%d]\n",
-                rq_depth, new_state, cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
+    pr_info(MPDEC_TAG"[DEBUG] rq: %u, new_state: %i | Mask=[%d%d%d%d]\n",
+            rq_depth, new_state, cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
 #endif
-	return new_state;
+    return new_state;
 }
 
-static void msm_mpdec_work_thread(struct work_struct *work)
-{
-	unsigned int cpu = nr_cpu_ids;
-	cputime64_t on_time = 0;
-        bool suspended = false;
+static void msm_mpdec_work_thread(struct work_struct *work) {
+    unsigned int cpu = nr_cpu_ids;
+    cputime64_t on_time = 0;
+    bool suspended = false;
 
-        if (ktime_to_ms(ktime_get()) <= msm_mpdec_tuners_ins.startdelay)
-                goto out;
+    if (ktime_to_ms(ktime_get()) <= msm_mpdec_tuners_ins.startdelay)
+            goto out;
 
-        /* Check if we are paused */
-        if (mpdec_paused_until >= ktime_to_ms(ktime_get()))
-                goto out;
+    /* Check if we are paused */
+    if (mpdec_paused_until >= ktime_to_ms(ktime_get()))
+            goto out;
 
+    for_each_possible_cpu(cpu) {
+        if ((per_cpu(msm_mpdec_cpudata, cpu).device_suspended == true)) {
+            suspended = true;
+            break;
+        }
+    }
+    if (suspended == true)
+        goto out;
+
+    if (!mutex_trylock(&mpdec_msm_cpu_lock))
+        goto out;
+
+    /* if sth messed with the cpus, update the check vars so we can proceed */
+    if (was_paused) {
         for_each_possible_cpu(cpu) {
-                if ((per_cpu(msm_mpdec_cpudata, cpu).device_suspended == true)) {
-                        suspended = true;
-                        break;
-                }
+            if (cpu_online(cpu))
+                per_cpu(msm_mpdec_cpudata, cpu).online = true;
+            else if (!cpu_online(cpu))
+                per_cpu(msm_mpdec_cpudata, cpu).online = false;
+        }
+        was_paused = false;
+    }
+
+    state = mp_decision();
+    switch (state) {
+    case MSM_MPDEC_DISABLED:
+    case MSM_MPDEC_IDLE:
+        break;
+    case MSM_MPDEC_DOWN:
+        cpu = get_slowest_cpu();
+        if (cpu < nr_cpu_ids) {
+            if ((per_cpu(msm_mpdec_cpudata, cpu).online == true) && (cpu_online(cpu))) {
+                cpu_down(cpu);
+                per_cpu(msm_mpdec_cpudata, cpu).online = false;
+                on_time = ktime_to_ms(ktime_get()) - per_cpu(msm_mpdec_cpudata, cpu).on_time;
+                per_cpu(msm_mpdec_cpudata, cpu).on_time_total += on_time;
+                per_cpu(msm_mpdec_cpudata, cpu).times_cpu_unplugged += 1;
+                pr_info(MPDEC_TAG"CPU[%d] on->off | Mask=[%d%d%d%d] | time online: %llu\n",
+                        cpu, cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3), on_time);
+            } else if (per_cpu(msm_mpdec_cpudata, cpu).online != cpu_online(cpu)) {
+                pr_info(MPDEC_TAG"CPU[%d] was controlled outside of mpdecision! | pausing [%d]ms\n",
+                        cpu, msm_mpdec_tuners_ins.pause);
+                mpdec_paused_until = ktime_to_ms(ktime_get()) + msm_mpdec_tuners_ins.pause;
+                was_paused = true;
+            }
         }
-	if (suspended == true)
-		goto out;
-
-	if (!mutex_trylock(&mpdec_msm_cpu_lock))
-		goto out;
-
-	/* if sth messed with the cpus, update the check vars so we can proceed */
-	if (was_paused) {
-		for_each_possible_cpu(cpu) {
-			if (cpu_online(cpu))
-				per_cpu(msm_mpdec_cpudata, cpu).online = true;
-			else if (!cpu_online(cpu))
-				per_cpu(msm_mpdec_cpudata, cpu).online = false;
-		}
-		was_paused = false;
-	}
-
-	state = mp_decision();
-	switch (state) {
-	case MSM_MPDEC_DISABLED:
-	case MSM_MPDEC_IDLE:
-		break;
-	case MSM_MPDEC_DOWN:
-		cpu = get_slowest_cpu();
-		if (cpu < nr_cpu_ids) {
-			if ((per_cpu(msm_mpdec_cpudata, cpu).online == true) && (cpu_online(cpu))) {
-				cpu_down(cpu);
-				per_cpu(msm_mpdec_cpudata, cpu).online = false;
-				on_time = ktime_to_ms(ktime_get()) - per_cpu(msm_mpdec_cpudata, cpu).on_time;
-				per_cpu(msm_mpdec_cpudata, cpu).on_time_total += on_time;
-				per_cpu(msm_mpdec_cpudata, cpu).times_cpu_unplugged += 1;
-				pr_info(MPDEC_TAG"CPU[%d] on->off | Mask=[%d%d%d%d] | time online: %llu\n",
-						cpu, cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3), on_time);
-			} else if (per_cpu(msm_mpdec_cpudata, cpu).online != cpu_online(cpu)) {
-				pr_info(MPDEC_TAG"CPU[%d] was controlled outside of mpdecision! | pausing [%d]ms\n",
-						cpu, msm_mpdec_tuners_ins.pause);
-				mpdec_paused_until = ktime_to_ms(ktime_get()) + msm_mpdec_tuners_ins.pause;
-				was_paused = true;
-			}
-		}
-		break;
-	case MSM_MPDEC_UP:
-		cpu = cpumask_next_zero(0, cpu_online_mask);
-		if (cpu < nr_cpu_ids) {
-			if ((per_cpu(msm_mpdec_cpudata, cpu).online == false) && (!cpu_online(cpu))) {
-				cpu_up(cpu);
-				per_cpu(msm_mpdec_cpudata, cpu).online = true;
-				per_cpu(msm_mpdec_cpudata, cpu).on_time = ktime_to_ms(ktime_get());
-				per_cpu(msm_mpdec_cpudata, cpu).times_cpu_hotplugged += 1;
-				pr_info(MPDEC_TAG"CPU[%d] off->on | Mask=[%d%d%d%d]\n",
-						cpu, cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
-			} else if (per_cpu(msm_mpdec_cpudata, cpu).online != cpu_online(cpu)) {
-				pr_info(MPDEC_TAG"CPU[%d] was controlled outside of mpdecision! | pausing [%d]ms\n",
-						cpu, msm_mpdec_tuners_ins.pause);
-				mpdec_paused_until = ktime_to_ms(ktime_get()) + msm_mpdec_tuners_ins.pause;
-				was_paused = true;
-			}
-		}
-		break;
-	default:
-		pr_err(MPDEC_TAG"%s: invalid mpdec hotplug state %d\n",
-		       __func__, state);
-	}
-	mutex_unlock(&mpdec_msm_cpu_lock);
+        break;
+    case MSM_MPDEC_UP:
+        cpu = cpumask_next_zero(0, cpu_online_mask);
+        if (cpu < nr_cpu_ids) {
+            if ((per_cpu(msm_mpdec_cpudata, cpu).online == false) && (!cpu_online(cpu))) {
+                cpu_up(cpu);
+                per_cpu(msm_mpdec_cpudata, cpu).online = true;
+                per_cpu(msm_mpdec_cpudata, cpu).on_time = ktime_to_ms(ktime_get());
+                per_cpu(msm_mpdec_cpudata, cpu).times_cpu_hotplugged += 1;
+                pr_info(MPDEC_TAG"CPU[%d] off->on | Mask=[%d%d%d%d]\n",
+                        cpu, cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
+            } else if (per_cpu(msm_mpdec_cpudata, cpu).online != cpu_online(cpu)) {
+                pr_info(MPDEC_TAG"CPU[%d] was controlled outside of mpdecision! | pausing [%d]ms\n",
+                        cpu, msm_mpdec_tuners_ins.pause);
+                mpdec_paused_until = ktime_to_ms(ktime_get()) + msm_mpdec_tuners_ins.pause;
+                was_paused = true;
+            }
+        }
+        break;
+    default:
+        pr_err(MPDEC_TAG"%s: invalid mpdec hotplug state %d\n",
+               __func__, state);
+    }
+    mutex_unlock(&mpdec_msm_cpu_lock);
 
 out:
-	if (state != MSM_MPDEC_DISABLED)
-		queue_delayed_work(msm_mpdec_workq, &msm_mpdec_work,
-				msecs_to_jiffies(msm_mpdec_tuners_ins.delay));
-	return;
+    if (state != MSM_MPDEC_DISABLED)
+        queue_delayed_work(msm_mpdec_workq, &msm_mpdec_work,
+                           msecs_to_jiffies(msm_mpdec_tuners_ins.delay));
+    return;
 }
 
-static void msm_mpdec_early_suspend(struct early_suspend *h)
-{
-	int cpu = nr_cpu_ids;
-	cputime64_t on_time = 0;
-	for_each_possible_cpu(cpu) {
-		mutex_lock(&per_cpu(msm_mpdec_cpudata, cpu).suspend_mutex);
-		if ((cpu >= 1) && (cpu_online(cpu))) {
-                        cpu_down(cpu);
-                        pr_info(MPDEC_TAG"Screen -> off. Suspended CPU[%d] | Mask=[%d%d%d%d]\n",
-                                cpu, cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
-			per_cpu(msm_mpdec_cpudata, cpu).online = false;
-			on_time = ktime_to_ms(ktime_get()) - per_cpu(msm_mpdec_cpudata, cpu).on_time;
-			per_cpu(msm_mpdec_cpudata, cpu).on_time_total += on_time;
-			per_cpu(msm_mpdec_cpudata, cpu).times_cpu_unplugged += 1;
-		}
-		per_cpu(msm_mpdec_cpudata, cpu).device_suspended = true;
-		mutex_unlock(&per_cpu(msm_mpdec_cpudata, cpu).suspend_mutex);
-	}
-        /* main work thread can sleep now */
-        cancel_delayed_work_sync(&msm_mpdec_work);
-
-        pr_info(MPDEC_TAG"Screen -> off. Deactivated mpdecision.\n");
-}
+static void msm_mpdec_early_suspend(struct early_suspend *h) {
+    int cpu = nr_cpu_ids;
+    cputime64_t on_time = 0;
+    for_each_possible_cpu(cpu) {
+        mutex_lock(&per_cpu(msm_mpdec_cpudata, cpu).suspend_mutex);
+        if ((cpu >= 1) && (cpu_online(cpu))) {
+            cpu_down(cpu);
+            pr_info(MPDEC_TAG"Screen -> off. Suspended CPU[%d] | Mask=[%d%d%d%d]\n",
+                    cpu, cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
+            per_cpu(msm_mpdec_cpudata, cpu).online = false;
+            on_time = ktime_to_ms(ktime_get()) - per_cpu(msm_mpdec_cpudata, cpu).on_time;
+            per_cpu(msm_mpdec_cpudata, cpu).on_time_total += on_time;
+            per_cpu(msm_mpdec_cpudata, cpu).times_cpu_unplugged += 1;
+        }
+        per_cpu(msm_mpdec_cpudata, cpu).device_suspended = true;
+        mutex_unlock(&per_cpu(msm_mpdec_cpudata, cpu).suspend_mutex);
+    }
+    /* main work thread can sleep now */
+    cancel_delayed_work_sync(&msm_mpdec_work);
 
-static void msm_mpdec_late_resume(struct early_suspend *h)
-{
-	int cpu = nr_cpu_ids;
-	for_each_possible_cpu(cpu)
-		per_cpu(msm_mpdec_cpudata, cpu).device_suspended = false;
-
-	mutex_lock(&per_cpu(msm_mpdec_cpudata, 1).suspend_mutex);
-	if (!cpu_online(1)) {
-		/* Always enable cpu1 when screen comes online.
-		 * This boosts the wakeup process. */
-		cpu_up(1);
-		per_cpu(msm_mpdec_cpudata, 1).on_time = ktime_to_ms(ktime_get());
-		per_cpu(msm_mpdec_cpudata, 1).online = true;
-		per_cpu(msm_mpdec_cpudata, 1).times_cpu_hotplugged += 1;
-		pr_info(MPDEC_TAG"Screen -> on. Hot plugged CPU1 | Mask=[%d%d%d%d]\n",
-                        cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
-	}
-	mutex_unlock(&per_cpu(msm_mpdec_cpudata, 1).suspend_mutex);
-
-        /* wake up main work thread */
-        was_paused = true;
-        queue_delayed_work(msm_mpdec_workq, &msm_mpdec_work, 0);
+    pr_info(MPDEC_TAG"Screen -> off. Deactivated mpdecision.\n");
+}
 
-        pr_info(MPDEC_TAG"Screen -> on. Activated mpdecision. | Mask=[%d%d%d%d]\n",
-		cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
+static void msm_mpdec_late_resume(struct early_suspend *h) {
+    int cpu = nr_cpu_ids;
+    for_each_possible_cpu(cpu)
+        per_cpu(msm_mpdec_cpudata, cpu).device_suspended = false;
+
+    mutex_lock(&per_cpu(msm_mpdec_cpudata, 1).suspend_mutex);
+    if (!cpu_online(1)) {
+        /* Always enable cpu1 when screen comes online.
+         * This boosts the wakeup process. */
+        cpu_up(1);
+        per_cpu(msm_mpdec_cpudata, 1).on_time = ktime_to_ms(ktime_get());
+        per_cpu(msm_mpdec_cpudata, 1).online = true;
+        per_cpu(msm_mpdec_cpudata, 1).times_cpu_hotplugged += 1;
+        pr_info(MPDEC_TAG"Screen -> on. Hot plugged CPU1 | Mask=[%d%d%d%d]\n",
+                cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
+    }
+    mutex_unlock(&per_cpu(msm_mpdec_cpudata, 1).suspend_mutex);
+
+    /* wake up main work thread */
+    was_paused = true;
+    queue_delayed_work(msm_mpdec_workq, &msm_mpdec_work, 0);
+
+    pr_info(MPDEC_TAG"Screen -> on. Activated mpdecision. | Mask=[%d%d%d%d]\n",
+            cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
 }
 
 static struct early_suspend msm_mpdec_early_suspend_handler = {
-	.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN,
-	.suspend = msm_mpdec_early_suspend,
-	.resume = msm_mpdec_late_resume,
+    .level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN,
+    .suspend = msm_mpdec_early_suspend,
+    .resume = msm_mpdec_late_resume,
 };
 
 /**************************** SYSFS START ****************************/
 struct kobject *msm_mpdec_kobject;
 
-#define show_one(file_name, object)					\
-static ssize_t show_##file_name						\
+#define show_one(file_name, object)                    \
+static ssize_t show_##file_name                        \
 (struct kobject *kobj, struct attribute *attr, char *buf)               \
-{									\
-	return sprintf(buf, "%u\n", msm_mpdec_tuners_ins.object);	\
+{                                    \
+    return sprintf(buf, "%u\n", msm_mpdec_tuners_ins.object);    \
 }
 
 show_one(startdelay, startdelay);
@@ -375,7 +366,7 @@ show_one(max_cpus, max_cpus);
 static ssize_t show_##file_name                                         \
 (struct kobject *kobj, struct attribute *attr, char *buf)               \
 {                                                                       \
-	return sprintf(buf, "%u\n", TwTs_Threshold[arraypos]);          \
+    return sprintf(buf, "%u\n", TwTs_Threshold[arraypos]);          \
 }
 show_one_twts(twts_threshold_0, 0);
 show_one_twts(twts_threshold_1, 1);
@@ -390,13 +381,13 @@ show_one_twts(twts_threshold_7, 7);
 static ssize_t store_##file_name                                        \
 (struct kobject *a, struct attribute *b, const char *buf, size_t count) \
 {                                                                       \
-	unsigned int input;                                             \
-	int ret;                                                        \
-	ret = sscanf(buf, "%u", &input);                                \
-	if (ret != 1)                                                   \
-		return -EINVAL;                                         \
-	TwTs_Threshold[arraypos] = input;                               \
-	return count;                                                   \
+    unsigned int input;                                             \
+    int ret;                                                        \
+    ret = sscanf(buf, "%u", &input);                                \
+    if (ret != 1)                                                   \
+        return -EINVAL;                                         \
+    TwTs_Threshold[arraypos] = input;                               \
+    return count;                                                   \
 }                                                                       \
 define_one_global_rw(file_name);
 store_one_twts(twts_threshold_0, 0);
@@ -412,7 +403,7 @@ store_one_twts(twts_threshold_7, 7);
 static ssize_t show_##file_name                                         \
 (struct kobject *kobj, struct attribute *attr, char *buf)               \
 {                                                                       \
-	return sprintf(buf, "%u\n", NwNs_Threshold[arraypos]);          \
+    return sprintf(buf, "%u\n", NwNs_Threshold[arraypos]);          \
 }
 show_one_nwns(nwns_threshold_0, 0);
 show_one_nwns(nwns_threshold_1, 1);
@@ -427,13 +418,13 @@ show_one_nwns(nwns_threshold_7, 7);
 static ssize_t store_##file_name                                        \
 (struct kobject *a, struct attribute *b, const char *buf, size_t count) \
 {                                                                       \
-	unsigned int input;                                             \
-	int ret;                                                        \
-	ret = sscanf(buf, "%u", &input);                                \
-	if (ret != 1)                                                   \
-		return -EINVAL;                                         \
-	NwNs_Threshold[arraypos] = input;                               \
-	return count;                                                   \
+    unsigned int input;                                             \
+    int ret;                                                        \
+    ret = sscanf(buf, "%u", &input);                                \
+    if (ret != 1)                                                   \
+        return -EINVAL;                                         \
+    NwNs_Threshold[arraypos] = input;                               \
+    return count;                                                   \
 }                                                                       \
 define_one_global_rw(file_name);
 store_one_nwns(nwns_threshold_0, 0);
@@ -448,185 +439,185 @@ store_one_nwns(nwns_threshold_7, 7);
 static ssize_t show_idle_freq (struct kobject *kobj, struct attribute *attr,
                                    char *buf)
 {
-	return sprintf(buf, "%lu\n", msm_mpdec_tuners_ins.idle_freq);
+    return sprintf(buf, "%lu\n", msm_mpdec_tuners_ins.idle_freq);
 }
 
 static ssize_t show_enabled(struct kobject *a, struct attribute *b,
-				   char *buf)
+                   char *buf)
 {
-	unsigned int enabled;
-	switch (state) {
-	case MSM_MPDEC_DISABLED:
-		enabled = 0;
-		break;
-	case MSM_MPDEC_IDLE:
-	case MSM_MPDEC_DOWN:
-	case MSM_MPDEC_UP:
-		enabled = 1;
-		break;
-	default:
-		enabled = 333;
-	}
-	return sprintf(buf, "%u\n", enabled);
+    unsigned int enabled;
+    switch (state) {
+    case MSM_MPDEC_DISABLED:
+        enabled = 0;
+        break;
+    case MSM_MPDEC_IDLE:
+    case MSM_MPDEC_DOWN:
+    case MSM_MPDEC_UP:
+        enabled = 1;
+        break;
+    default:
+        enabled = 333;
+    }
+    return sprintf(buf, "%u\n", enabled);
 }
 
 static ssize_t store_startdelay(struct kobject *a, struct attribute *b,
-				   const char *buf, size_t count)
+                   const char *buf, size_t count)
 {
-	unsigned int input;
-	int ret;
-	ret = sscanf(buf, "%u", &input);
-	if (ret != 1)
-		return -EINVAL;
+    unsigned int input;
+    int ret;
+    ret = sscanf(buf, "%u", &input);
+    if (ret != 1)
+        return -EINVAL;
 
-	msm_mpdec_tuners_ins.startdelay = input;
+    msm_mpdec_tuners_ins.startdelay = input;
 
-	return count;
+    return count;
 }
 
 static ssize_t store_delay(struct kobject *a, struct attribute *b,
-				   const char *buf, size_t count)
+                   const char *buf, size_t count)
 {
-	unsigned int input;
-	int ret;
-	ret = sscanf(buf, "%u", &input);
-	if (ret != 1)
-		return -EINVAL;
+    unsigned int input;
+    int ret;
+    ret = sscanf(buf, "%u", &input);
+    if (ret != 1)
+        return -EINVAL;
 
-	msm_mpdec_tuners_ins.delay = input;
+    msm_mpdec_tuners_ins.delay = input;
 
-	return count;
+    return count;
 }
 
 static ssize_t store_pause(struct kobject *a, struct attribute *b,
-				   const char *buf, size_t count)
+                   const char *buf, size_t count)
 {
-	unsigned int input;
-	int ret;
-	ret = sscanf(buf, "%u", &input);
-	if (ret != 1)
-		return -EINVAL;
+    unsigned int input;
+    int ret;
+    ret = sscanf(buf, "%u", &input);
+    if (ret != 1)
+        return -EINVAL;
 
-	msm_mpdec_tuners_ins.pause = input;
+    msm_mpdec_tuners_ins.pause = input;
 
-	return count;
+    return count;
 }
 
 static ssize_t store_idle_freq(struct kobject *a, struct attribute *b,
-				   const char *buf, size_t count)
+                   const char *buf, size_t count)
 {
-	long unsigned int input;
-	int ret;
-	ret = sscanf(buf, "%lu", &input);
-	if (ret != 1)
-		return -EINVAL;
+    long unsigned int input;
+    int ret;
+    ret = sscanf(buf, "%lu", &input);
+    if (ret != 1)
+        return -EINVAL;
 
-	msm_mpdec_tuners_ins.idle_freq = input;
+    msm_mpdec_tuners_ins.idle_freq = input;
 
-	return count;
+    return count;
 }
 
 static ssize_t store_scroff_single_core(struct kobject *a, struct attribute *b,
-				   const char *buf, size_t count)
+                   const char *buf, size_t count)
 {
-	unsigned int input;
-	int ret;
-	ret = sscanf(buf, "%u", &input);
-	if (ret != 1)
-		return -EINVAL;
-	switch (buf[0]) {
-	case '0':
-		msm_mpdec_tuners_ins.scroff_single_core = input;
-		break;
-	case '1':
-		msm_mpdec_tuners_ins.scroff_single_core = input;
-		break;
-	default:
-		ret = -EINVAL;
-	}
-	return count;
+    unsigned int input;
+    int ret;
+    ret = sscanf(buf, "%u", &input);
+    if (ret != 1)
+        return -EINVAL;
+    switch (buf[0]) {
+    case '0':
+        msm_mpdec_tuners_ins.scroff_single_core = input;
+        break;
+    case '1':
+        msm_mpdec_tuners_ins.scroff_single_core = input;
+        break;
+    default:
+        ret = -EINVAL;
+    }
+    return count;
 }
 
 static ssize_t store_max_cpus(struct kobject *a, struct attribute *b,
-				   const char *buf, size_t count)
+                   const char *buf, size_t count)
 {
-	unsigned int input;
-	int ret;
-	ret = sscanf(buf, "%u", &input);
-	if ((ret != 1) || input > CONFIG_NR_CPUS)
+    unsigned int input;
+    int ret;
+    ret = sscanf(buf, "%u", &input);
+    if ((ret != 1) || input > CONFIG_NR_CPUS)
                 return -EINVAL;
 
-	msm_mpdec_tuners_ins.max_cpus = input;
+    msm_mpdec_tuners_ins.max_cpus = input;
 
-	return count;
+    return count;
 }
 
 static ssize_t store_min_cpus(struct kobject *a, struct attribute *b,
-				   const char *buf, size_t count)
+                   const char *buf, size_t count)
 {
-	unsigned int input;
-	int ret;
-	ret = sscanf(buf, "%u", &input);
-	if ((ret != 1) || input < 1)
-                return -EINVAL;
+    unsigned int input;
+    int ret;
+    ret = sscanf(buf, "%u", &input);
+    if ((ret != 1) || input < 1)
+        return -EINVAL;
 
-	msm_mpdec_tuners_ins.min_cpus = input;
+    msm_mpdec_tuners_ins.min_cpus = input;
 
-	return count;
+    return count;
 }
 
 static ssize_t store_enabled(struct kobject *a, struct attribute *b,
-				   const char *buf, size_t count)
+                   const char *buf, size_t count)
 {
-	unsigned int cpu, input, enabled;
-	int ret;
-	ret = sscanf(buf, "%u", &input);
-	if (ret != 1)
-		return -EINVAL;
-
-	switch (state) {
-	case MSM_MPDEC_DISABLED:
-		enabled = 0;
-		break;
-	case MSM_MPDEC_IDLE:
-	case MSM_MPDEC_DOWN:
-	case MSM_MPDEC_UP:
-		enabled = 1;
-		break;
-	default:
-		enabled = 333;
-	}
-
-	if (buf[0] == enabled)
-		return -EINVAL;
-
-	switch (buf[0]) {
-	case '0':
-		state = MSM_MPDEC_DISABLED;
-                pr_info(MPDEC_TAG"nap time... Hot plugging offline CPUs...\n");
-
-                for (cpu = 1; cpu < CONFIG_NR_CPUS; cpu++) {
-                        if (!cpu_online(cpu)) {
-                                per_cpu(msm_mpdec_cpudata, cpu).on_time = ktime_to_ms(ktime_get());
-                                per_cpu(msm_mpdec_cpudata, cpu).online = true;
-                                per_cpu(msm_mpdec_cpudata, cpu).times_cpu_hotplugged += 1;
-                                cpu_up(cpu);
-                                pr_info(MPDEC_TAG"nap time... Hot plugged CPU[%d] | Mask=[%d%d%d%d]\n",
-                                        cpu, cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
-                        }
-                }
-		break;
-	case '1':
-		state = MSM_MPDEC_IDLE;
-		was_paused = true;
-		queue_delayed_work(msm_mpdec_workq, &msm_mpdec_work,
-                                   msecs_to_jiffies(msm_mpdec_tuners_ins.delay));
-		pr_info(MPDEC_TAG"firing up mpdecision...\n");
-		break;
-	default:
-		ret = -EINVAL;
-	}
-	return count;
+    unsigned int cpu, input, enabled;
+    int ret;
+    ret = sscanf(buf, "%u", &input);
+    if (ret != 1)
+        return -EINVAL;
+
+    switch (state) {
+    case MSM_MPDEC_DISABLED:
+        enabled = 0;
+        break;
+    case MSM_MPDEC_IDLE:
+    case MSM_MPDEC_DOWN:
+    case MSM_MPDEC_UP:
+        enabled = 1;
+        break;
+    default:
+        enabled = 333;
+    }
+
+    if (buf[0] == enabled)
+        return -EINVAL;
+
+    switch (buf[0]) {
+    case '0':
+        state = MSM_MPDEC_DISABLED;
+        pr_info(MPDEC_TAG"nap time... Hot plugging offline CPUs...\n");
+
+        for (cpu = 1; cpu < CONFIG_NR_CPUS; cpu++) {
+            if (!cpu_online(cpu)) {
+                per_cpu(msm_mpdec_cpudata, cpu).on_time = ktime_to_ms(ktime_get());
+                per_cpu(msm_mpdec_cpudata, cpu).online = true;
+                per_cpu(msm_mpdec_cpudata, cpu).times_cpu_hotplugged += 1;
+                cpu_up(cpu);
+                pr_info(MPDEC_TAG"nap time... Hot plugged CPU[%d] | Mask=[%d%d%d%d]\n",
+                        cpu, cpu_online(0), cpu_online(1), cpu_online(2), cpu_online(3));
+            }
+        }
+        break;
+    case '1':
+        state = MSM_MPDEC_IDLE;
+        was_paused = true;
+        queue_delayed_work(msm_mpdec_workq, &msm_mpdec_work,
+                           msecs_to_jiffies(msm_mpdec_tuners_ins.delay));
+        pr_info(MPDEC_TAG"firing up mpdecision...\n");
+        break;
+    default:
+        ret = -EINVAL;
+    }
+    return count;
 }
 
 define_one_global_rw(startdelay);
@@ -639,146 +630,145 @@ define_one_global_rw(max_cpus);
 define_one_global_rw(enabled);
 
 static struct attribute *msm_mpdec_attributes[] = {
-	&startdelay.attr,
-	&delay.attr,
-	&pause.attr,
-	&scroff_single_core.attr,
-	&idle_freq.attr,
-        &min_cpus.attr,
-        &max_cpus.attr,
-	&enabled.attr,
-	&twts_threshold_0.attr,
-	&twts_threshold_1.attr,
-	&twts_threshold_2.attr,
-	&twts_threshold_3.attr,
-	&twts_threshold_4.attr,
-	&twts_threshold_5.attr,
-	&twts_threshold_6.attr,
-	&twts_threshold_7.attr,
-	&nwns_threshold_0.attr,
-	&nwns_threshold_1.attr,
-	&nwns_threshold_2.attr,
-	&nwns_threshold_3.attr,
-	&nwns_threshold_4.attr,
-	&nwns_threshold_5.attr,
-	&nwns_threshold_6.attr,
-	&nwns_threshold_7.attr,
-	NULL
+    &startdelay.attr,
+    &delay.attr,
+    &pause.attr,
+    &scroff_single_core.attr,
+    &idle_freq.attr,
+    &min_cpus.attr,
+    &max_cpus.attr,
+    &enabled.attr,
+    &twts_threshold_0.attr,
+    &twts_threshold_1.attr,
+    &twts_threshold_2.attr,
+    &twts_threshold_3.attr,
+    &twts_threshold_4.attr,
+    &twts_threshold_5.attr,
+    &twts_threshold_6.attr,
+    &twts_threshold_7.attr,
+    &nwns_threshold_0.attr,
+    &nwns_threshold_1.attr,
+    &nwns_threshold_2.attr,
+    &nwns_threshold_3.attr,
+    &nwns_threshold_4.attr,
+    &nwns_threshold_5.attr,
+    &nwns_threshold_6.attr,
+    &nwns_threshold_7.attr,
+    NULL
 };
 
 
 static struct attribute_group msm_mpdec_attr_group = {
-	.attrs = msm_mpdec_attributes,
-	.name = "conf",
+    .attrs = msm_mpdec_attributes,
+    .name = "conf",
 };
 
 /********* STATS START *********/
 
 static ssize_t show_time_cpus_on(struct kobject *a, struct attribute *b,
-				   char *buf)
+                   char *buf)
 {
-	ssize_t len = 0;
-	int cpu = 0;
+    ssize_t len = 0;
+    int cpu = 0;
 
-	for_each_possible_cpu(cpu) {
-		len += sprintf(buf + len, "%i %llu\n", cpu, per_cpu(msm_mpdec_cpudata, cpu).on_time_total);
-	}
+    for_each_possible_cpu(cpu) {
+        len += sprintf(buf + len, "%i %llu\n", cpu, per_cpu(msm_mpdec_cpudata, cpu).on_time_total);
+    }
 
-	return len;
+    return len;
 }
 define_one_global_ro(time_cpus_on);
 
 static ssize_t show_times_cpus_hotplugged(struct kobject *a, struct attribute *b,
-				   char *buf)
+                   char *buf)
 {
-	ssize_t len = 0;
-	int cpu = 0;
+    ssize_t len = 0;
+    int cpu = 0;
 
-	for_each_possible_cpu(cpu) {
-		len += sprintf(buf + len, "%i %llu\n", cpu, per_cpu(msm_mpdec_cpudata, cpu).times_cpu_hotplugged);
-	}
+    for_each_possible_cpu(cpu) {
+        len += sprintf(buf + len, "%i %llu\n", cpu, per_cpu(msm_mpdec_cpudata, cpu).times_cpu_hotplugged);
+    }
 
-	return len;
+    return len;
 }
 define_one_global_ro(times_cpus_hotplugged);
 
 static ssize_t show_times_cpus_unplugged(struct kobject *a, struct attribute *b,
-				   char *buf)
+                   char *buf)
 {
-	ssize_t len = 0;
-	int cpu = 0;
+    ssize_t len = 0;
+    int cpu = 0;
 
-	for_each_possible_cpu(cpu) {
-		len += sprintf(buf + len, "%i %llu\n", cpu, per_cpu(msm_mpdec_cpudata, cpu).times_cpu_unplugged);
-	}
+    for_each_possible_cpu(cpu) {
+        len += sprintf(buf + len, "%i %llu\n", cpu, per_cpu(msm_mpdec_cpudata, cpu).times_cpu_unplugged);
+    }
 
-	return len;
+    return len;
 }
 define_one_global_ro(times_cpus_unplugged);
 
 static struct attribute *msm_mpdec_stats_attributes[] = {
-	&time_cpus_on.attr,
-	&times_cpus_hotplugged.attr,
-	&times_cpus_unplugged.attr,
-	NULL
+    &time_cpus_on.attr,
+    &times_cpus_hotplugged.attr,
+    &times_cpus_unplugged.attr,
+    NULL
 };
 
 
 static struct attribute_group msm_mpdec_stats_attr_group = {
-	.attrs = msm_mpdec_stats_attributes,
-	.name = "stats",
+    .attrs = msm_mpdec_stats_attributes,
+    .name = "stats",
 };
 /**************************** SYSFS END ****************************/
 
-static int __init msm_mpdec_init(void)
-{
-	int cpu, rc, err = 0;
-
-	for_each_possible_cpu(cpu) {
-		mutex_init(&(per_cpu(msm_mpdec_cpudata, cpu).suspend_mutex));
-		per_cpu(msm_mpdec_cpudata, cpu).device_suspended = false;
-		per_cpu(msm_mpdec_cpudata, cpu).online = true;
-		per_cpu(msm_mpdec_cpudata, cpu).on_time_total = 0;
-		per_cpu(msm_mpdec_cpudata, cpu).times_cpu_unplugged = 0;
-		per_cpu(msm_mpdec_cpudata, cpu).times_cpu_hotplugged = 0;
-	}
+static int __init msm_mpdec_init(void) {
+    int cpu, rc, err = 0;
+
+    for_each_possible_cpu(cpu) {
+        mutex_init(&(per_cpu(msm_mpdec_cpudata, cpu).suspend_mutex));
+        per_cpu(msm_mpdec_cpudata, cpu).device_suspended = false;
+        per_cpu(msm_mpdec_cpudata, cpu).online = true;
+        per_cpu(msm_mpdec_cpudata, cpu).on_time_total = 0;
+        per_cpu(msm_mpdec_cpudata, cpu).times_cpu_unplugged = 0;
+        per_cpu(msm_mpdec_cpudata, cpu).times_cpu_hotplugged = 0;
+    }
+
+    was_paused = true;
+
+    msm_mpdec_workq = alloc_workqueue("mpdec",
+                                      WQ_UNBOUND | WQ_RESCUER | WQ_FREEZABLE,
+                                      1);
+    if (!msm_mpdec_workq)
+        return -ENOMEM;
+    INIT_DELAYED_WORK(&msm_mpdec_work, msm_mpdec_work_thread);
+    if (state != MSM_MPDEC_DISABLED)
+        queue_delayed_work(msm_mpdec_workq, &msm_mpdec_work,
+                           msecs_to_jiffies(msm_mpdec_tuners_ins.delay));
+
+    register_early_suspend(&msm_mpdec_early_suspend_handler);
+
+    msm_mpdec_kobject = kobject_create_and_add("msm_mpdecision", kernel_kobj);
+    if (msm_mpdec_kobject) {
+        rc = sysfs_create_group(msm_mpdec_kobject,
+                                &msm_mpdec_attr_group);
+        if (rc) {
+            pr_warn(MPDEC_TAG"sysfs: ERROR, could not create sysfs group");
+        }
+        rc = sysfs_create_group(msm_mpdec_kobject,
+                                &msm_mpdec_stats_attr_group);
+        if (rc) {
+            pr_warn(MPDEC_TAG"sysfs: ERROR, could not create sysfs stats group");
+        }
+    } else
+        pr_warn(MPDEC_TAG"sysfs: ERROR, could not create sysfs kobj");
 
-        was_paused = true;
+    pr_info(MPDEC_TAG"%s init complete.", __func__);
 
-        msm_mpdec_workq = alloc_workqueue(
-                "mpdec", WQ_UNBOUND | WQ_RESCUER | WQ_FREEZABLE, 1);
-        if (!msm_mpdec_workq)
-                return -ENOMEM;
-	INIT_DELAYED_WORK(&msm_mpdec_work, msm_mpdec_work_thread);
-	if (state != MSM_MPDEC_DISABLED)
-		queue_delayed_work(msm_mpdec_workq, &msm_mpdec_work,
-                                   msecs_to_jiffies(msm_mpdec_tuners_ins.delay));
-
-	register_early_suspend(&msm_mpdec_early_suspend_handler);
-
-	msm_mpdec_kobject = kobject_create_and_add("msm_mpdecision", kernel_kobj);
-	if (msm_mpdec_kobject) {
-		rc = sysfs_create_group(msm_mpdec_kobject,
-							&msm_mpdec_attr_group);
-		if (rc) {
-			pr_warn(MPDEC_TAG"sysfs: ERROR, could not create sysfs group");
-		}
-		rc = sysfs_create_group(msm_mpdec_kobject,
-							&msm_mpdec_stats_attr_group);
-		if (rc) {
-			pr_warn(MPDEC_TAG"sysfs: ERROR, could not create sysfs stats group");
-		}
-	} else
-		pr_warn(MPDEC_TAG"sysfs: ERROR, could not create sysfs kobj");
-
-	pr_info(MPDEC_TAG"%s init complete.", __func__);
-
-	return err;
+    return err;
 }
 late_initcall(msm_mpdec_init);
 
-void msm_mpdec_exit(void)
-{
-        destroy_workqueue(msm_mpdec_workq);
-        destroy_workqueue(msm_mpdec_workq);
+void msm_mpdec_exit(void) {
+    destroy_workqueue(msm_mpdec_workq);
+    destroy_workqueue(msm_mpdec_workq);
 }
-- 
1.7.9.5

